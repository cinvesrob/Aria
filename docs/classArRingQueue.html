<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Aria: ArRingQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aria
   &#160;<span id="projectnumber">2.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classArRingQueue.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classArRingQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ArRingQueue&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__UtilityClasses.html">Utility Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An expanding ring queue.  
 <a href="classArRingQueue.html#details">More...</a></p>

<p><code>#include &lt;ArRingQueue.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae73cb1d2cec1e663c1157bc71b1d7f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#ae73cb1d2cec1e663c1157bc71b1d7f4d">advance_back</a> ()</td></tr>
<tr class="memdesc:ae73cb1d2cec1e663c1157bc71b1d7f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the back (an 'empty' push), if the queue is not full.  <a href="#ae73cb1d2cec1e663c1157bc71b1d7f4d">More...</a><br /></td></tr>
<tr class="separator:ae73cb1d2cec1e663c1157bc71b1d7f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa7e60371c7601f4e794d3e21e708f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a7fa7e60371c7601f4e794d3e21e708f2">advance_front</a> ()</td></tr>
<tr class="memdesc:a7fa7e60371c7601f4e794d3e21e708f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance (pop) the front of the queue.  <a href="#a7fa7e60371c7601f4e794d3e21e708f2">More...</a><br /></td></tr>
<tr class="separator:a7fa7e60371c7601f4e794d3e21e708f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27771d7817cc4d0453d0b6b215913406"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a27771d7817cc4d0453d0b6b215913406">ArRingQueue</a> (int <a class="el" href="classArRingQueue.html#a8d871f45e6528a36060b5541bee81fdb">capacity</a>, T init_value)</td></tr>
<tr class="separator:a27771d7817cc4d0453d0b6b215913406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8121a2877cfd695eed752e38249e196"><td class="memItemLeft" align="right" valign="top">std::list&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#ac8121a2877cfd695eed752e38249e196">back</a> ()</td></tr>
<tr class="memdesc:ac8121a2877cfd695eed752e38249e196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the back of the queue (the item that would be replaced by <a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b" title="Add an item to the back of the ring queue. ">push()</a>).  <a href="#ac8121a2877cfd695eed752e38249e196">More...</a><br /></td></tr>
<tr class="separator:ac8121a2877cfd695eed752e38249e196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d871f45e6528a36060b5541bee81fdb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a8d871f45e6528a36060b5541bee81fdb">capacity</a> ()</td></tr>
<tr class="memdesc:a8d871f45e6528a36060b5541bee81fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current capacity of the queue.  <a href="#a8d871f45e6528a36060b5541bee81fdb">More...</a><br /></td></tr>
<tr class="separator:a8d871f45e6528a36060b5541bee81fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab0881bade43ecf422ec9a472d2acd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#afab0881bade43ecf422ec9a472d2acd3">empty</a> ()</td></tr>
<tr class="memdesc:afab0881bade43ecf422ec9a472d2acd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is empty (has no 'used' items), false otherwise.  <a href="#afab0881bade43ecf422ec9a472d2acd3">More...</a><br /></td></tr>
<tr class="separator:afab0881bade43ecf422ec9a472d2acd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaee28c1ea0a02b095691c9889d6058a"><td class="memItemLeft" align="right" valign="top">std::list&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#adaee28c1ea0a02b095691c9889d6058a">front</a> ()</td></tr>
<tr class="memdesc:adaee28c1ea0a02b095691c9889d6058a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the front item of the ring queue (the item that would be returned by pop()).  <a href="#adaee28c1ea0a02b095691c9889d6058a">More...</a><br /></td></tr>
<tr class="separator:adaee28c1ea0a02b095691c9889d6058a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f53abdfb4bc727120b62d814964cb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a18f53abdfb4bc727120b62d814964cb8">full</a> ()</td></tr>
<tr class="memdesc:a18f53abdfb4bc727120b62d814964cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is full, false otherwise.  <a href="#a18f53abdfb4bc727120b62d814964cb8">More...</a><br /></td></tr>
<tr class="separator:a18f53abdfb4bc727120b62d814964cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13605ef610f6092febeef27017e42a09"><td class="memItemLeft" align="right" valign="top">std::list&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a13605ef610f6092febeef27017e42a09">nil</a> ()</td></tr>
<tr class="memdesc:a13605ef610f6092febeef27017e42a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator representing an invalid item.  <a href="#a13605ef610f6092febeef27017e42a09">More...</a><br /></td></tr>
<tr class="separator:a13605ef610f6092febeef27017e42a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3239e02c975282a01f5a2c9f6daede"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e3239e02c975282a01f5a2c9f6daede"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a0e3239e02c975282a01f5a2c9f6daede">pop_front</a> ()</td></tr>
<tr class="memdesc:a0e3239e02c975282a01f5a2c9f6daede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classArRingQueue.html#a7fa7e60371c7601f4e794d3e21e708f2" title="Advance (pop) the front of the queue. ">advance_front()</a> <br /></td></tr>
<tr class="separator:a0e3239e02c975282a01f5a2c9f6daede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a049222bb51b8c94383b9669bbd4462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a1a049222bb51b8c94383b9669bbd4462">print</a> ()</td></tr>
<tr class="memdesc:a1a049222bb51b8c94383b9669bbd4462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current contents of the queue.  <a href="#a1a049222bb51b8c94383b9669bbd4462">More...</a><br /></td></tr>
<tr class="separator:a1a049222bb51b8c94383b9669bbd4462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de53f01e95093f30083dc551081e51b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b">push</a> (const T &amp;item)</td></tr>
<tr class="memdesc:a0de53f01e95093f30083dc551081e51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an item to the back of the ring queue.  <a href="#a0de53f01e95093f30083dc551081e51b">More...</a><br /></td></tr>
<tr class="separator:a0de53f01e95093f30083dc551081e51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929c549542dcfd3b8cbc4a0d0d838347"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a929c549542dcfd3b8cbc4a0d0d838347"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a929c549542dcfd3b8cbc4a0d0d838347">push_back</a> (const T &amp;item)</td></tr>
<tr class="memdesc:a929c549542dcfd3b8cbc4a0d0d838347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b" title="Add an item to the back of the ring queue. ">push()</a> <br /></td></tr>
<tr class="separator:a929c549542dcfd3b8cbc4a0d0d838347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac6c08ebabfa4bc5aa36375e7d98e7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaac6c08ebabfa4bc5aa36375e7d98e7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#aaac6c08ebabfa4bc5aa36375e7d98e7a">push_without_expanding</a> (const T &amp;item)</td></tr>
<tr class="memdesc:aaac6c08ebabfa4bc5aa36375e7d98e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a new item, but preserve capacity: instead of expanding the queue if full, then the oldest item is replaced and the front is advanced. <br /></td></tr>
<tr class="separator:aaac6c08ebabfa4bc5aa36375e7d98e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e45c61b16569112fa265c9d3d305c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#a16e45c61b16569112fa265c9d3d305c1">reset</a> ()</td></tr>
<tr class="memdesc:a16e45c61b16569112fa265c9d3d305c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logically clear the queue, resetting to initial empty state, but preserving current capacity, and leaving all contents as they are; the contents are not destroyed, but will be when replaced by new data later.  <a href="#a16e45c61b16569112fa265c9d3d305c1">More...</a><br /></td></tr>
<tr class="separator:a16e45c61b16569112fa265c9d3d305c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a4a6353e476f0c592e2ce973c50d45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#af0a4a6353e476f0c592e2ce973c50d45">size</a> ()</td></tr>
<tr class="memdesc:af0a4a6353e476f0c592e2ce973c50d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items currently 'used' in the queue.  <a href="#af0a4a6353e476f0c592e2ce973c50d45">More...</a><br /></td></tr>
<tr class="separator:af0a4a6353e476f0c592e2ce973c50d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a137b4511f42c7c89f39628c4f0fadd77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a137b4511f42c7c89f39628c4f0fadd77"></a>
std::list&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>back_it</b></td></tr>
<tr class="separator:a137b4511f42c7c89f39628c4f0fadd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485ae4c6963acb5d65cd46e810bf5f84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a485ae4c6963acb5d65cd46e810bf5f84"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>curSize</b></td></tr>
<tr class="separator:a485ae4c6963acb5d65cd46e810bf5f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97b459ece928efe22c4c7349c730e68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad97b459ece928efe22c4c7349c730e68"></a>
std::list&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>front_it</b></td></tr>
<tr class="separator:ad97b459ece928efe22c4c7349c730e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d39ad7769e9ddec117d693d99536acc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d39ad7769e9ddec117d693d99536acc"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>initval</b></td></tr>
<tr class="separator:a1d39ad7769e9ddec117d693d99536acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbab8c20581b04a7c51af5b4a6c5800e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbab8c20581b04a7c51af5b4a6c5800e"></a>
std::list&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ring</b></td></tr>
<tr class="separator:adbab8c20581b04a7c51af5b4a6c5800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class ArRingQueue&lt; T &gt;</h3>

<p>An expanding ring queue. </p>
<p>It is used to keep a queue with a minimum of allocation and freeing of heap memory. The ring queue is implemented using std::list. The queue starts with an initial capacity, but those initial items are considered 'unused'. Items are "pushed" into the queue at the "back", and "popped" from the queue at the "front". pop() and <a class="el" href="classArRingQueue.html#a7fa7e60371c7601f4e794d3e21e708f2" title="Advance (pop) the front of the queue. ">advance_front()</a> will move the front of the queue to the next item, creating a new 'unused slot' for future use; <a class="el" href="classArRingQueue.html#ae73cb1d2cec1e663c1157bc71b1d7f4d" title="Advance the back (an &#39;empty&#39; push), if the queue is not full. ">advance_back()</a> changes the next item in the back to a 'used' slot. <a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b" title="Add an item to the back of the ring queue. ">push()</a> either uses the next 'unused' slot, or inserts a new item into the std::list. When the capacity of the queue is filled, all operations will fail except <a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b" title="Add an item to the back of the ring queue. ">push()</a>. Use <a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b" title="Add an item to the back of the ring queue. ">push()</a> to insert new items in the queue and increase its capacity.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a27771d7817cc4d0453d0b6b215913406"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::<a class="el" href="classArRingQueue.html">ArRingQueue</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Initial capacity of the ring queue. </td></tr>
    <tr><td class="paramname">init_value</td><td>Initial value for new, unused items in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae73cb1d2cec1e663c1157bc71b1d7f4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::advance_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the back (an 'empty' push), if the queue is not full. </p>
<p>'Used' size will be incremented. </p>

</div>
</div>
<a class="anchor" id="a7fa7e60371c7601f4e794d3e21e708f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::advance_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance (pop) the front of the queue. </p>
<p>'Used' size will be decremented. </p>

</div>
</div>
<a class="anchor" id="ac8121a2877cfd695eed752e38249e196"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;T&gt;::iterator <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator for the back of the queue (the item that would be replaced by <a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b" title="Add an item to the back of the ring queue. ">push()</a>). </p>
<p>This is not the last item in the queue, rather it is the next, unused, "slot". If the queue is full, an iterator equivalent to that returned by <a class="el" href="classArRingQueue.html#a13605ef610f6092febeef27017e42a09" title="Return an iterator representing an invalid item. ">nil()</a> is returned.</p>
<p>To add an item to the queue without pushing a copy with <a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b" title="Add an item to the back of the ring queue. ">push()</a>, first check if the queue is full (in which case you must <a class="el" href="classArRingQueue.html#a0de53f01e95093f30083dc551081e51b" title="Add an item to the back of the ring queue. ">push()</a> your item). Then use this function to write the data into the next unused 'slot'. Then call <a class="el" href="classArRingQueue.html#ae73cb1d2cec1e663c1157bc71b1d7f4d" title="Advance the back (an &#39;empty&#39; push), if the queue is not full. ">advance_back()</a> to advance the back of the queue to your new item. </p>

</div>
</div>
<a class="anchor" id="a8d871f45e6528a36060b5541bee81fdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current capacity of the queue. </p>

</div>
</div>
<a class="anchor" id="afab0881bade43ecf422ec9a472d2acd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue is empty (has no 'used' items), false otherwise. </p>

</div>
</div>
<a class="anchor" id="adaee28c1ea0a02b095691c9889d6058a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;T&gt;::iterator <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator for the front item of the ring queue (the item that would be returned by pop()). </p>
<p>If the queue is currently empty, <a class="el" href="classArRingQueue.html#a13605ef610f6092febeef27017e42a09" title="Return an iterator representing an invalid item. ">nil()</a> will be returned.</p>
<p>To remove an item from the queue without making a copy with pop(), first check if the queue is <a class="el" href="classArRingQueue.html#afab0881bade43ecf422ec9a472d2acd3" title="Return true if the queue is empty (has no &#39;used&#39; items), false otherwise. ">empty()</a>. Then use this function to get the data. Then call <a class="el" href="classArRingQueue.html#a7fa7e60371c7601f4e794d3e21e708f2" title="Advance (pop) the front of the queue. ">advance_front()</a>. </p>

</div>
</div>
<a class="anchor" id="a18f53abdfb4bc727120b62d814964cb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue is full, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a13605ef610f6092febeef27017e42a09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;T&gt;::iterator <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::nil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator representing an invalid item. </p>
<p>Compare to the return values of <a class="el" href="classArRingQueue.html#adaee28c1ea0a02b095691c9889d6058a" title="Get an iterator for the front item of the ring queue (the item that would be returned by pop())...">front()</a>, <a class="el" href="classArRingQueue.html#ac8121a2877cfd695eed752e38249e196" title="Get an iterator for the back of the queue (the item that would be replaced by push()). ">back()</a>, pop(), etc. </p>

</div>
</div>
<a class="anchor" id="a1a049222bb51b8c94383b9669bbd4462"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the current contents of the queue. </p>
<p><b>Python Wrapper Library:</b> use printQueue() instead of <a class="el" href="classArRingQueue.html#a1a049222bb51b8c94383b9669bbd4462" title="Print the current contents of the queue. ">print()</a> (which is a reserved word in Python) </p>

</div>
</div>
<a class="anchor" id="a0de53f01e95093f30083dc551081e51b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an item to the back of the ring queue. </p>
<p>If the queue is full, the capacity of the queue will be expanded and the item will be inserted. </p>

</div>
</div>
<a class="anchor" id="a16e45c61b16569112fa265c9d3d305c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logically clear the queue, resetting to initial empty state, but preserving current capacity, and leaving all contents as they are; the contents are not destroyed, but will be when replaced by new data later. </p>

</div>
</div>
<a class="anchor" id="af0a4a6353e476f0c592e2ce973c50d45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items currently 'used' in the queue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ArRingQueue.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classArRingQueue.html">ArRingQueue</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
