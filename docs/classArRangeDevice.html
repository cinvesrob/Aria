<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Aria: ArRangeDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aria
   &#160;<span id="projectnumber">2.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classArRangeDevice.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classArRangeDevice-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ArRangeDevice Class Reference<div class="ingroups"><a class="el" href="group__ImportantClasses.html">Important Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The base class for all sensing devices which return range information from the device (mounted on a robot) to an object in the environment.  
 <a href="classArRangeDevice.html#details">More...</a></p>

<p><code>#include &lt;ArRangeDevice.h&gt;</code></p>

<p>Inherited by <a class="el" href="classArBumpers.html">ArBumpers</a>, <a class="el" href="classArForbiddenRangeDevice.html">ArForbiddenRangeDevice</a>, <a class="el" href="classArIrrfDevice.html">ArIrrfDevice</a>, <a class="el" href="classArIRs.html">ArIRs</a>, <a class="el" href="classArLaserReflectorDevice.html">ArLaserReflectorDevice</a>, <a class="el" href="classArRangeDeviceThreaded.html">ArRangeDeviceThreaded</a>, <a class="el" href="classArSonarDevice.html">ArSonarDevice</a>, ExampleRangeDevice<code> [virtual]</code>, and ExampleRangeDevice<code> [virtual]</code>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06398798458c23f70065baac04471146"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06398798458c23f70065baac04471146"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a06398798458c23f70065baac04471146">addReading</a> (double x, double y, bool *wasAdded=NULL)</td></tr>
<tr class="memdesc:a06398798458c23f70065baac04471146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a reading to the buffer. <br /></td></tr>
<tr class="separator:a06398798458c23f70065baac04471146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e29948ca6b640272faf43dfe5c4870"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ab7e29948ca6b640272faf43dfe5c4870">applyTransform</a> (<a class="el" href="classArTransform.html">ArTransform</a> trans, bool doCumulative=true)</td></tr>
<tr class="memdesc:ab7e29948ca6b640272faf43dfe5c4870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transform to the buffers.  <a href="#ab7e29948ca6b640272faf43dfe5c4870">More...</a><br /></td></tr>
<tr class="separator:ab7e29948ca6b640272faf43dfe5c4870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5317e9755d5ef4ddda1acbfd5c79f2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ae5317e9755d5ef4ddda1acbfd5c79f2f">ArRangeDevice</a> (size_t currentBufferSize, size_t cumulativeBufferSize, const char *name, unsigned int maxRange, int maxSecondsToKeepCurrent=0, int maxSecondsToKeepCumulative=0, double maxDistToKeepCumulative=0, bool locationDependent=false)</td></tr>
<tr class="memdesc:ae5317e9755d5ef4ddda1acbfd5c79f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae5317e9755d5ef4ddda1acbfd5c79f2f">More...</a><br /></td></tr>
<tr class="separator:ae5317e9755d5ef4ddda1acbfd5c79f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c90a21b4f4a1c51bc9d124e217a8ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20c90a21b4f4a1c51bc9d124e217a8ef"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a20c90a21b4f4a1c51bc9d124e217a8ef">clearCumulativeOlderThan</a> (int milliSeconds)</td></tr>
<tr class="memdesc:a20c90a21b4f4a1c51bc9d124e217a8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all the cumulative readings older than this number of milliseconds. <br /></td></tr>
<tr class="separator:a20c90a21b4f4a1c51bc9d124e217a8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd491aff714eb3a6924b63d12d65351"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcd491aff714eb3a6924b63d12d65351"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#adcd491aff714eb3a6924b63d12d65351">clearCumulativeOlderThanSeconds</a> (int seconds)</td></tr>
<tr class="memdesc:adcd491aff714eb3a6924b63d12d65351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all the cumulative readings older than this number of seconds. <br /></td></tr>
<tr class="separator:adcd491aff714eb3a6924b63d12d65351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82eb3d017534465a60b384ac56f1d2e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82eb3d017534465a60b384ac56f1d2e8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a82eb3d017534465a60b384ac56f1d2e8">clearCumulativeReadings</a> (void)</td></tr>
<tr class="memdesc:a82eb3d017534465a60b384ac56f1d2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all the cumulative readings. <br /></td></tr>
<tr class="separator:a82eb3d017534465a60b384ac56f1d2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb9b6ff83ae33a4a5bbe22eb825d1f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eb9b6ff83ae33a4a5bbe22eb825d1f5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a8eb9b6ff83ae33a4a5bbe22eb825d1f5">clearCurrentReadings</a> (void)</td></tr>
<tr class="memdesc:a8eb9b6ff83ae33a4a5bbe22eb825d1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all the current readings. <br /></td></tr>
<tr class="separator:a8eb9b6ff83ae33a4a5bbe22eb825d1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeab2edd7763ac30d2b33c1cf08bb915"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#adeab2edd7763ac30d2b33c1cf08bb915">cumulativeReadingBox</a> (double x1, double y1, double x2, double y2, <a class="el" href="classArPose.html">ArPose</a> *readingPos=NULL) const </td></tr>
<tr class="memdesc:adeab2edd7763ac30d2b33c1cf08bb915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the closest current reading from the given box region.  <a href="#adeab2edd7763ac30d2b33c1cf08bb915">More...</a><br /></td></tr>
<tr class="separator:adeab2edd7763ac30d2b33c1cf08bb915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c898926eb1c04ed457c8e5c3e7566e3"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a3c898926eb1c04ed457c8e5c3e7566e3">cumulativeReadingPolar</a> (double startAngle, double endAngle, double *angle=NULL) const </td></tr>
<tr class="memdesc:a3c898926eb1c04ed457c8e5c3e7566e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the closest cumulative reading in the given polar region.  <a href="#a3c898926eb1c04ed457c8e5c3e7566e3">More...</a><br /></td></tr>
<tr class="separator:a3c898926eb1c04ed457c8e5c3e7566e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac262870eb43b21b1be17ee8621eb3b91"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ac262870eb43b21b1be17ee8621eb3b91">currentReadingBox</a> (double x1, double y1, double x2, double y2, <a class="el" href="classArPose.html">ArPose</a> *readingPos=NULL) const </td></tr>
<tr class="memdesc:ac262870eb43b21b1be17ee8621eb3b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the closest current reading from the given box region.  <a href="#ac262870eb43b21b1be17ee8621eb3b91">More...</a><br /></td></tr>
<tr class="separator:ac262870eb43b21b1be17ee8621eb3b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b080d64bdedd8f593ffcc6c373d609"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a27b080d64bdedd8f593ffcc6c373d609">currentReadingPolar</a> (double startAngle, double endAngle, double *angle=NULL) const </td></tr>
<tr class="memdesc:a27b080d64bdedd8f593ffcc6c373d609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the closest current reading in the given polar region.  <a href="#a27b080d64bdedd8f593ffcc6c373d609">More...</a><br /></td></tr>
<tr class="separator:a27b080d64bdedd8f593ffcc6c373d609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6c1ba0cd2ac91887cac2856e048c77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf6c1ba0cd2ac91887cac2856e048c77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aaf6c1ba0cd2ac91887cac2856e048c77">filterCallback</a> (void)</td></tr>
<tr class="memdesc:aaf6c1ba0cd2ac91887cac2856e048c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to filter the readings based on age and distance. <br /></td></tr>
<tr class="separator:aaf6c1ba0cd2ac91887cac2856e048c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad025cfa7204fb601f8b5de95bde9b"><td class="memItemLeft" align="right" valign="top">virtual const std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a08ad025cfa7204fb601f8b5de95bde9b">getAdjustedRawReadings</a> (void) const </td></tr>
<tr class="memdesc:a08ad025cfa7204fb601f8b5de95bde9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the raw unfiltered readings from the device (but pose takens are corrected)  <a href="#a08ad025cfa7204fb601f8b5de95bde9b">More...</a><br /></td></tr>
<tr class="separator:a08ad025cfa7204fb601f8b5de95bde9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41b98c9f5fdef7916a09433f871e940"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ac41b98c9f5fdef7916a09433f871e940">getAdjustedRawReadingsAsVector</a> (void)</td></tr>
<tr class="memdesc:ac41b98c9f5fdef7916a09433f871e940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the raw adjusted readings from the device into a vector.  <a href="#ac41b98c9f5fdef7916a09433f871e940">More...</a><br /></td></tr>
<tr class="separator:ac41b98c9f5fdef7916a09433f871e940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3ac9142453f941bc92ba241436453d"><td class="memItemLeft" align="right" valign="top">virtual const std::list&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aad3ac9142453f941bc92ba241436453d">getCumulativeBuffer</a> (void) const </td></tr>
<tr class="memdesc:aad3ac9142453f941bc92ba241436453d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current buffer of readings.  <a href="#aad3ac9142453f941bc92ba241436453d">More...</a><br /></td></tr>
<tr class="separator:aad3ac9142453f941bc92ba241436453d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eb459ed07f7ed361cacc7212db35dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83eb459ed07f7ed361cacc7212db35dd"></a>
virtual std::list&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a83eb459ed07f7ed361cacc7212db35dd">getCumulativeBuffer</a> (void)</td></tr>
<tr class="memdesc:a83eb459ed07f7ed361cacc7212db35dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current buffer of readings. <br /></td></tr>
<tr class="separator:a83eb459ed07f7ed361cacc7212db35dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8030e121b625a123286f98a328a5b2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aaa8030e121b625a123286f98a328a5b2">getCumulativeBufferAsVector</a> (void)</td></tr>
<tr class="memdesc:aaa8030e121b625a123286f98a328a5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cumulative buffer of readings as a vector.  <a href="#aaa8030e121b625a123286f98a328a5b2">More...</a><br /></td></tr>
<tr class="separator:aaa8030e121b625a123286f98a328a5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e418e0f7970357893d010d02def770"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e418e0f7970357893d010d02def770"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a49e418e0f7970357893d010d02def770">getCumulativeBufferSize</a> (void) const </td></tr>
<tr class="memdesc:a49e418e0f7970357893d010d02def770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum size of the buffer for cumulative readings. <br /></td></tr>
<tr class="separator:a49e418e0f7970357893d010d02def770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d14df2fcd274798d4a886a7b926bff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d14df2fcd274798d4a886a7b926bff"></a>
virtual <a class="el" href="classArDrawingData.html">ArDrawingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a69d14df2fcd274798d4a886a7b926bff">getCumulativeDrawingData</a> (void)</td></tr>
<tr class="memdesc:a69d14df2fcd274798d4a886a7b926bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets data used for visualizing the cumulative buffer (see ArNetworking) <br /></td></tr>
<tr class="separator:a69d14df2fcd274798d4a886a7b926bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc6078a128d80de304d5b978baaf31d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aefc6078a128d80de304d5b978baaf31d">getCumulativeRangeBuffer</a> (void) const </td></tr>
<tr class="memdesc:aefc6078a128d80de304d5b978baaf31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cumulative range buffer.  <a href="#aefc6078a128d80de304d5b978baaf31d">More...</a><br /></td></tr>
<tr class="separator:aefc6078a128d80de304d5b978baaf31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064f0165f2a406145e6a8939fd17dfb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a064f0165f2a406145e6a8939fd17dfb9"></a>
virtual <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a064f0165f2a406145e6a8939fd17dfb9">getCumulativeRangeBuffer</a> (void)</td></tr>
<tr class="memdesc:a064f0165f2a406145e6a8939fd17dfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cumulative range buffer. <br /></td></tr>
<tr class="separator:a064f0165f2a406145e6a8939fd17dfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072ac84980687ed353b3e5c2e36d6d68"><td class="memItemLeft" align="right" valign="top">virtual const std::list&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a072ac84980687ed353b3e5c2e36d6d68">getCurrentBuffer</a> (void) const </td></tr>
<tr class="memdesc:a072ac84980687ed353b3e5c2e36d6d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current buffer of readings.  <a href="#a072ac84980687ed353b3e5c2e36d6d68">More...</a><br /></td></tr>
<tr class="separator:a072ac84980687ed353b3e5c2e36d6d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1395143f849a819e08a10bf6542503ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1395143f849a819e08a10bf6542503ca"></a>
virtual std::list&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a1395143f849a819e08a10bf6542503ca">getCurrentBuffer</a> (void)</td></tr>
<tr class="memdesc:a1395143f849a819e08a10bf6542503ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current buffer of readings. <br /></td></tr>
<tr class="separator:a1395143f849a819e08a10bf6542503ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c1207063423f113406c9de528fc320"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a91c1207063423f113406c9de528fc320">getCurrentBufferAsVector</a> (void)</td></tr>
<tr class="memdesc:a91c1207063423f113406c9de528fc320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current buffer of readings as a vector.  <a href="#a91c1207063423f113406c9de528fc320">More...</a><br /></td></tr>
<tr class="separator:a91c1207063423f113406c9de528fc320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ed5e194cea9d9d68012c783c53f9be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1ed5e194cea9d9d68012c783c53f9be"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#af1ed5e194cea9d9d68012c783c53f9be">getCurrentBufferSize</a> (void) const </td></tr>
<tr class="memdesc:af1ed5e194cea9d9d68012c783c53f9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum size of the buffer for current readings. <br /></td></tr>
<tr class="separator:af1ed5e194cea9d9d68012c783c53f9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbebb9e3252d1449acff674ebc0c7a10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbebb9e3252d1449acff674ebc0c7a10"></a>
virtual <a class="el" href="classArDrawingData.html">ArDrawingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#acbebb9e3252d1449acff674ebc0c7a10">getCurrentDrawingData</a> (void)</td></tr>
<tr class="memdesc:acbebb9e3252d1449acff674ebc0c7a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets data used for visualizing the current buffer (see ArNetworking) <br /></td></tr>
<tr class="separator:acbebb9e3252d1449acff674ebc0c7a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e497d7893beb13ef903861ba909087"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ad5e497d7893beb13ef903861ba909087">getCurrentRangeBuffer</a> (void) const </td></tr>
<tr class="memdesc:ad5e497d7893beb13ef903861ba909087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current range buffer.  <a href="#ad5e497d7893beb13ef903861ba909087">More...</a><br /></td></tr>
<tr class="separator:ad5e497d7893beb13ef903861ba909087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6690dffb87973976b557b8190162e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6690dffb87973976b557b8190162e8"></a>
virtual <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#acf6690dffb87973976b557b8190162e8">getCurrentRangeBuffer</a> (void)</td></tr>
<tr class="memdesc:acf6690dffb87973976b557b8190162e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current range buffer. <br /></td></tr>
<tr class="separator:acf6690dffb87973976b557b8190162e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc5cdd9adb55399d4e0725754c418ca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aefc5cdd9adb55399d4e0725754c418ca">getMaxDistToKeepCumulative</a> (void)</td></tr>
<tr class="memdesc:aefc5cdd9adb55399d4e0725754c418ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the maximum distance cumulative readings can be from current pose  <a href="#aefc5cdd9adb55399d4e0725754c418ca">More...</a><br /></td></tr>
<tr class="separator:aefc5cdd9adb55399d4e0725754c418ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506d33c0b4e405476ce2b56097bcbce8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a506d33c0b4e405476ce2b56097bcbce8">getMaxInsertDistCumulative</a> (void)</td></tr>
<tr class="memdesc:a506d33c0b4e405476ce2b56097bcbce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum distance a cumulative reading can be from the robot and still be inserted.  <a href="#a506d33c0b4e405476ce2b56097bcbce8">More...</a><br /></td></tr>
<tr class="separator:a506d33c0b4e405476ce2b56097bcbce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532ea3f49df7591a9ff537743352746e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a532ea3f49df7591a9ff537743352746e"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a532ea3f49df7591a9ff537743352746e">getMaxRange</a> (void) const </td></tr>
<tr class="memdesc:a532ea3f49df7591a9ff537743352746e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum range for this device. <br /></td></tr>
<tr class="separator:a532ea3f49df7591a9ff537743352746e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9c853607709dd259d406c0356edc5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a3f9c853607709dd259d406c0356edc5b">getMaxSecondsToKeepCumulative</a> (void)</td></tr>
<tr class="memdesc:a3f9c853607709dd259d406c0356edc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the maximum seconds to keep current readings around  <a href="#a3f9c853607709dd259d406c0356edc5b">More...</a><br /></td></tr>
<tr class="separator:a3f9c853607709dd259d406c0356edc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51152724f047e69c2aec79bde36ece1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a51152724f047e69c2aec79bde36ece1f">getMaxSecondsToKeepCurrent</a> (void)</td></tr>
<tr class="memdesc:a51152724f047e69c2aec79bde36ece1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the maximum seconds to keep current readings around  <a href="#a51152724f047e69c2aec79bde36ece1f">More...</a><br /></td></tr>
<tr class="separator:a51152724f047e69c2aec79bde36ece1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900eac07d508c59f5026e423e7777864"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a900eac07d508c59f5026e423e7777864">getMinDistBetweenCumulative</a> (void)</td></tr>
<tr class="memdesc:a900eac07d508c59f5026e423e7777864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum distance between cumulative readings.  <a href="#a900eac07d508c59f5026e423e7777864">More...</a><br /></td></tr>
<tr class="separator:a900eac07d508c59f5026e423e7777864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafc983b6f747863b93c5258b18a4076"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aaafc983b6f747863b93c5258b18a4076">getMinDistBetweenCurrent</a> (void)</td></tr>
<tr class="memdesc:aaafc983b6f747863b93c5258b18a4076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum distance between current readings.  <a href="#aaafc983b6f747863b93c5258b18a4076">More...</a><br /></td></tr>
<tr class="separator:aaafc983b6f747863b93c5258b18a4076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf76b644d209c28628a1f7ba4047b60b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf76b644d209c28628a1f7ba4047b60b"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#adf76b644d209c28628a1f7ba4047b60b">getName</a> (void) const </td></tr>
<tr class="memdesc:adf76b644d209c28628a1f7ba4047b60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the device. <br /></td></tr>
<tr class="separator:adf76b644d209c28628a1f7ba4047b60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f1591ab4bcd08ffeab0254aaf7568b"><td class="memItemLeft" align="right" valign="top">virtual const std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ac3f1591ab4bcd08ffeab0254aaf7568b">getRawReadings</a> (void) const </td></tr>
<tr class="memdesc:ac3f1591ab4bcd08ffeab0254aaf7568b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the raw unfiltered readings from the device.  <a href="#ac3f1591ab4bcd08ffeab0254aaf7568b">More...</a><br /></td></tr>
<tr class="separator:ac3f1591ab4bcd08ffeab0254aaf7568b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fdf4c7e7c95ac8e5605df3c87ee1dc"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a97fdf4c7e7c95ac8e5605df3c87ee1dc">getRawReadingsAsVector</a> (void)</td></tr>
<tr class="memdesc:a97fdf4c7e7c95ac8e5605df3c87ee1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the raw unfiltered readings from the device into a vector.  <a href="#a97fdf4c7e7c95ac8e5605df3c87ee1dc">More...</a><br /></td></tr>
<tr class="separator:a97fdf4c7e7c95ac8e5605df3c87ee1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70473f04371cb1b4bcac83f1e2cd5a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae70473f04371cb1b4bcac83f1e2cd5a2"></a>
virtual <a class="el" href="classArRobot.html">ArRobot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ae70473f04371cb1b4bcac83f1e2cd5a2">getRobot</a> (void)</td></tr>
<tr class="memdesc:ae70473f04371cb1b4bcac83f1e2cd5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the robot this device is attached to. <br /></td></tr>
<tr class="separator:ae70473f04371cb1b4bcac83f1e2cd5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e4bf48910f725221760a202206a1e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22e4bf48910f725221760a202206a1e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a22e4bf48910f725221760a202206a1e9">isLocationDependent</a> (void)</td></tr>
<tr class="memdesc:a22e4bf48910f725221760a202206a1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets if this device is location dependent or not. <br /></td></tr>
<tr class="separator:a22e4bf48910f725221760a202206a1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172e8da71d800f959523e1f3021612d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a172e8da71d800f959523e1f3021612d8"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a172e8da71d800f959523e1f3021612d8">lockDevice</a> ()</td></tr>
<tr class="memdesc:a172e8da71d800f959523e1f3021612d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock this device. <br /></td></tr>
<tr class="separator:a172e8da71d800f959523e1f3021612d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f7fa1ed25b92afed4de0cb957c313c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ad4f7fa1ed25b92afed4de0cb957c313c">setCumulativeBufferSize</a> (size_t size)</td></tr>
<tr class="memdesc:ad4f7fa1ed25b92afed4de0cb957c313c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum size of the buffer for cumulative readings.  <a href="#ad4f7fa1ed25b92afed4de0cb957c313c">More...</a><br /></td></tr>
<tr class="separator:ad4f7fa1ed25b92afed4de0cb957c313c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ac42251d038f50250117e7ae21cbdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5ac42251d038f50250117e7ae21cbdc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ac5ac42251d038f50250117e7ae21cbdc">setCumulativeDrawingData</a> (<a class="el" href="classArDrawingData.html">ArDrawingData</a> *data, bool takeOwnershipOfData)</td></tr>
<tr class="memdesc:ac5ac42251d038f50250117e7ae21cbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets data for visualizing the cumulative buffer (and if we own it) <br /></td></tr>
<tr class="separator:ac5ac42251d038f50250117e7ae21cbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73bae003a4e3f89f8bddfc843db464"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a0e73bae003a4e3f89f8bddfc843db464">setCurrentBufferSize</a> (size_t size)</td></tr>
<tr class="memdesc:a0e73bae003a4e3f89f8bddfc843db464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum size of the buffer for current readings.  <a href="#a0e73bae003a4e3f89f8bddfc843db464">More...</a><br /></td></tr>
<tr class="separator:a0e73bae003a4e3f89f8bddfc843db464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b09eb692d4c9d0f9b51cca41f9e9665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b09eb692d4c9d0f9b51cca41f9e9665"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a7b09eb692d4c9d0f9b51cca41f9e9665">setCurrentDrawingData</a> (<a class="el" href="classArDrawingData.html">ArDrawingData</a> *data, bool takeOwnershipOfData)</td></tr>
<tr class="memdesc:a7b09eb692d4c9d0f9b51cca41f9e9665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets data for visualizing the current buffer (and if we own it) <br /></td></tr>
<tr class="separator:a7b09eb692d4c9d0f9b51cca41f9e9665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1ec2efa5f2d6d34683586919847aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a3f1ec2efa5f2d6d34683586919847aa2">setMaxDistToKeepCumulative</a> (double maxDistToKeepCumulative)</td></tr>
<tr class="memdesc:a3f1ec2efa5f2d6d34683586919847aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the maximum distance cumulative readings can be from current pose  <a href="#a3f1ec2efa5f2d6d34683586919847aa2">More...</a><br /></td></tr>
<tr class="separator:a3f1ec2efa5f2d6d34683586919847aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65aaec7f213c343f6c096584928463cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a65aaec7f213c343f6c096584928463cc">setMaxInsertDistCumulative</a> (double maxInsertDistCumulative)</td></tr>
<tr class="memdesc:a65aaec7f213c343f6c096584928463cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum distance a cumulative reading can be from the robot and still be inserted.  <a href="#a65aaec7f213c343f6c096584928463cc">More...</a><br /></td></tr>
<tr class="separator:a65aaec7f213c343f6c096584928463cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a31e62e62d21f870c2b4f2f8ec5ceee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a31e62e62d21f870c2b4f2f8ec5ceee"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a7a31e62e62d21f870c2b4f2f8ec5ceee">setMaxRange</a> (unsigned int maxRange)</td></tr>
<tr class="memdesc:a7a31e62e62d21f870c2b4f2f8ec5ceee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum range for this device. <br /></td></tr>
<tr class="separator:a7a31e62e62d21f870c2b4f2f8ec5ceee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d797854910a43b6650fb4cee3d8626f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a6d797854910a43b6650fb4cee3d8626f">setMaxSecondsToKeepCumulative</a> (int maxSecondsToKeepCumulative)</td></tr>
<tr class="memdesc:a6d797854910a43b6650fb4cee3d8626f"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the maximum seconds to keep cumulative readings around  <a href="#a6d797854910a43b6650fb4cee3d8626f">More...</a><br /></td></tr>
<tr class="separator:a6d797854910a43b6650fb4cee3d8626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab963e49e5a08704ac08ab7eab040fa8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ab963e49e5a08704ac08ab7eab040fa8c">setMaxSecondsToKeepCurrent</a> (int maxSecondsToKeepCurrent)</td></tr>
<tr class="memdesc:ab963e49e5a08704ac08ab7eab040fa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum seconds to keep current readings around.  <a href="#ab963e49e5a08704ac08ab7eab040fa8c">More...</a><br /></td></tr>
<tr class="separator:ab963e49e5a08704ac08ab7eab040fa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd53bf7cfbba205118c79ab95c8c3f18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#acd53bf7cfbba205118c79ab95c8c3f18">setMinDistBetweenCumulative</a> (double minDistBetweenCumulative)</td></tr>
<tr class="memdesc:acd53bf7cfbba205118c79ab95c8c3f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum distance between cumulative readings.  <a href="#acd53bf7cfbba205118c79ab95c8c3f18">More...</a><br /></td></tr>
<tr class="separator:acd53bf7cfbba205118c79ab95c8c3f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b9e8840205f7d1b60a55f27490c1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ab3b9e8840205f7d1b60a55f27490c1ab">setMinDistBetweenCurrent</a> (double minDistBetweenCurrent)</td></tr>
<tr class="memdesc:ab3b9e8840205f7d1b60a55f27490c1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum distance between current readings.  <a href="#ab3b9e8840205f7d1b60a55f27490c1ab">More...</a><br /></td></tr>
<tr class="separator:ab3b9e8840205f7d1b60a55f27490c1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d3eeb36b5347c006e844ee7a103b96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5d3eeb36b5347c006e844ee7a103b96"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ab5d3eeb36b5347c006e844ee7a103b96">setRobot</a> (<a class="el" href="classArRobot.html">ArRobot</a> *robot)</td></tr>
<tr class="memdesc:ab5d3eeb36b5347c006e844ee7a103b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the robot this device is attached to. <br /></td></tr>
<tr class="separator:ab5d3eeb36b5347c006e844ee7a103b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f74c2d3090f1c6d94c24bdec580165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9f74c2d3090f1c6d94c24bdec580165"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ad9f74c2d3090f1c6d94c24bdec580165">tryLockDevice</a> ()</td></tr>
<tr class="memdesc:ad9f74c2d3090f1c6d94c24bdec580165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock this device. <br /></td></tr>
<tr class="separator:ad9f74c2d3090f1c6d94c24bdec580165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af889a070950aae211df4637fbb73608e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af889a070950aae211df4637fbb73608e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#af889a070950aae211df4637fbb73608e">unlockDevice</a> ()</td></tr>
<tr class="memdesc:af889a070950aae211df4637fbb73608e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock this device. <br /></td></tr>
<tr class="separator:af889a070950aae211df4637fbb73608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166b2f88c88663ba337db50a008b5e83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a166b2f88c88663ba337db50a008b5e83"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a166b2f88c88663ba337db50a008b5e83">~ArRangeDevice</a> ()</td></tr>
<tr class="memdesc:a166b2f88c88663ba337db50a008b5e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a166b2f88c88663ba337db50a008b5e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7774762a642a206a3b57bac9876ba5af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a7774762a642a206a3b57bac9876ba5af">adjustRawReadings</a> (bool interlaced)</td></tr>
<tr class="memdesc:a7774762a642a206a3b57bac9876ba5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call should be called by the range device every robot cycle before the range device makes new readings (and even if it isn't adding any that cycle)...  <a href="#a7774762a642a206a3b57bac9876ba5af">More...</a><br /></td></tr>
<tr class="separator:a7774762a642a206a3b57bac9876ba5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afa6d02a16900d73887a8004d3e239278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa6d02a16900d73887a8004d3e239278"></a>
std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>myAdjustedRawReadings</b></td></tr>
<tr class="separator:afa6d02a16900d73887a8004d3e239278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db7c1b2099396b066f5645e80547e93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8db7c1b2099396b066f5645e80547e93"></a>
std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>myAdjustedRawReadingsVector</b></td></tr>
<tr class="separator:a8db7c1b2099396b066f5645e80547e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ce26c1762c4bb167601c3c09260bbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ce26c1762c4bb167601c3c09260bbe"></a>
<a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>myCumulativeBuffer</b></td></tr>
<tr class="separator:ad5ce26c1762c4bb167601c3c09260bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace130bb2f40f0179bd455df84cb8bd88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace130bb2f40f0179bd455df84cb8bd88"></a>
<a class="el" href="classArDrawingData.html">ArDrawingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>myCumulativeDrawingData</b></td></tr>
<tr class="separator:ace130bb2f40f0179bd455df84cb8bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8be8e72cbac3f38c430c72b279de2a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8be8e72cbac3f38c430c72b279de2a6"></a>
<a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>myCurrentBuffer</b></td></tr>
<tr class="separator:af8be8e72cbac3f38c430c72b279de2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d810d3867aa7be92560b6228f8717b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d810d3867aa7be92560b6228f8717b"></a>
<a class="el" href="classArDrawingData.html">ArDrawingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>myCurrentDrawingData</b></td></tr>
<tr class="separator:a69d810d3867aa7be92560b6228f8717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffcd7fc1f49cf175686e22c9b4fd43f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ffcd7fc1f49cf175686e22c9b4fd43f"></a>
<a class="el" href="classArMutex.html">ArMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>myDeviceMutex</b></td></tr>
<tr class="separator:a9ffcd7fc1f49cf175686e22c9b4fd43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6032f65f02bb4bc14dacb2eee628a64c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6032f65f02bb4bc14dacb2eee628a64c"></a>
<a class="el" href="classArFunctorC.html">ArFunctorC</a>&lt; <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>myFilterCB</b></td></tr>
<tr class="separator:a6032f65f02bb4bc14dacb2eee628a64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2222f1480d57c93193b861c087c7d502"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2222f1480d57c93193b861c087c7d502"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>myIsLocationDependent</b></td></tr>
<tr class="separator:a2222f1480d57c93193b861c087c7d502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c63c8b7f611a97f98428d5f018c4a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0c63c8b7f611a97f98428d5f018c4a6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myMaxDistToKeepCumulative</b></td></tr>
<tr class="separator:ad0c63c8b7f611a97f98428d5f018c4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab74723892344efd4e702b174d345736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab74723892344efd4e702b174d345736"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myMaxDistToKeepCumulativeSquared</b></td></tr>
<tr class="separator:aab74723892344efd4e702b174d345736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3383185644b9a1ce860e7d13001838d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3383185644b9a1ce860e7d13001838d5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulative</b></td></tr>
<tr class="separator:a3383185644b9a1ce860e7d13001838d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b3dd8bb3d34a534514dc8112afba00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21b3dd8bb3d34a534514dc8112afba00"></a>
<a class="el" href="classArPose.html">ArPose</a>&#160;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulativePose</b></td></tr>
<tr class="separator:a21b3dd8bb3d34a534514dc8112afba00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9a9e1f96b36ac5685bbfe706cfe204"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc9a9e1f96b36ac5685bbfe706cfe204"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulativeSquared</b></td></tr>
<tr class="separator:adc9a9e1f96b36ac5685bbfe706cfe204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c35fe4536d577557a9942276ab41fce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c35fe4536d577557a9942276ab41fce"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>myMaxRange</b></td></tr>
<tr class="separator:a8c35fe4536d577557a9942276ab41fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309f620a84332c7c1258548776494978"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a309f620a84332c7c1258548776494978"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>myMaxSecondsToKeepCumulative</b></td></tr>
<tr class="separator:a309f620a84332c7c1258548776494978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c58006d4790190630b2a2543aedd37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c58006d4790190630b2a2543aedd37"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>myMaxSecondsToKeepCurrent</b></td></tr>
<tr class="separator:ae5c58006d4790190630b2a2543aedd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9500f36938ed5273ba048bec649cba4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9500f36938ed5273ba048bec649cba4c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCumulative</b></td></tr>
<tr class="separator:a9500f36938ed5273ba048bec649cba4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7386deb78492c085340c3b9de8f467f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7386deb78492c085340c3b9de8f467f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCumulativeSquared</b></td></tr>
<tr class="separator:ad7386deb78492c085340c3b9de8f467f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca0e64151e39728b80114f39e4499b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11ca0e64151e39728b80114f39e4499b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCurrent</b></td></tr>
<tr class="separator:a11ca0e64151e39728b80114f39e4499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00af2617c176f3726702f4208d14b156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00af2617c176f3726702f4208d14b156"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCurrentSquared</b></td></tr>
<tr class="separator:a00af2617c176f3726702f4208d14b156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e41abc839a5525f42f6d8ead74a71ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e41abc839a5525f42f6d8ead74a71ab"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>myName</b></td></tr>
<tr class="separator:a5e41abc839a5525f42f6d8ead74a71ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6091650d6b5882f21c11eb393ae56aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6091650d6b5882f21c11eb393ae56aa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>myOwnCumulativeDrawingData</b></td></tr>
<tr class="separator:af6091650d6b5882f21c11eb393ae56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad57fee938b1b73104400fa033a74aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ad57fee938b1b73104400fa033a74aa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>myOwnCurrentDrawingData</b></td></tr>
<tr class="separator:a9ad57fee938b1b73104400fa033a74aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5307cac3fefd997e644307f6c5c129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea5307cac3fefd997e644307f6c5c129"></a>
std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>myRawReadings</b></td></tr>
<tr class="separator:aea5307cac3fefd997e644307f6c5c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3053a123a93b8c8f9e4e92838136f6aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3053a123a93b8c8f9e4e92838136f6aa"></a>
std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>myRawReadingsVector</b></td></tr>
<tr class="separator:a3053a123a93b8c8f9e4e92838136f6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29abe2d368550e7a5756ece2908aadc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29abe2d368550e7a5756ece2908aadc6"></a>
<a class="el" href="classArRobot.html">ArRobot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>myRobot</b></td></tr>
<tr class="separator:a29abe2d368550e7a5756ece2908aadc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base class for all sensing devices which return range information from the device (mounted on a robot) to an object in the environment. </p>
<p>This class maintains two <a class="el" href="classArRangeBuffer.html" title="This class is a buffer that holds ranging information. ">ArRangeBuffer</a> objects: a current buffer (<a class="el" href="classArRangeDevice.html#a072ac84980687ed353b3e5c2e36d6d68" title="Gets the current buffer of readings. ">getCurrentBuffer()</a>) for storing very recent readings, and a cumulative buffer (<a class="el" href="classArRangeDevice.html#aad3ac9142453f941bc92ba241436453d" title="Gets the current buffer of readings. ">getCumulativeBuffer()</a>) for a longer history of readings. The maximum sizes of each buffer can be set in the constructor or resized later. Range device readings are most often represented as a point in space (X,Y) where the sensor detected an object. (Therefore an <a class="el" href="classArPose.html" title="Represents an x, y position with an orientation. ">ArPose</a> object may only have X and Y components set).</p>
<p>Some devices provide an original set of "raw" <a class="el" href="classArSensorReading.html" title="Used to convert and store data from and/or about a range sensor. ">ArSensorReading</a> objects (<a class="el" href="classArRangeDevice.html#ac3f1591ab4bcd08ffeab0254aaf7568b" title="Gets the raw unfiltered readings from the device. ">getRawReadings()</a>) (that it used to add data to the current buffer) which may also include extra device specific information as well. Not all devices provide raw readings.</p>
<p>Subclasses are used for specific sensor implementations like <a class="el" href="classArLaser.html" title="ArRangeDevice interface specialized for laser rangefinder sensors; see ArRangeDevice for more data ac...">ArLaser</a> and subclasses for laser rangefinders and <a class="el" href="classArSonarDevice.html" title="Keep track of recent sonar readings from a robot as an ArRangeDevice. ">ArSonarDevice</a> for the Pioneer sonar array. It can also be useful to treat "virtual" objects like forbidden areas specified by the user in a map like range devices. Some of these subsclasses may use a separate thread to update the range reading buffers, and so this base class provides "lock" and "unlock" methods which you should use when accessing device data.</p>
<p>A range device may have an <a class="el" href="classArRobot.html" title="Central class for communicating with and operating the robot. ">ArRobot</a> object associated with it. A range device may also be associated with an <a class="el" href="classArRobot.html" title="Central class for communicating with and operating the robot. ">ArRobot</a> by calling <a class="el" href="classArRobot.html#a97d57b28549fdef851c00749a97cc776" title="Adds a rangeDevice to the robot&#39;s list of them, and set the ArRangeDevice object&#39;s robot pointer to t...">ArRobot::addRangeDevice()</a>. <a class="el" href="classArRobot.html" title="Central class for communicating with and operating the robot. ">ArRobot</a> provides functions which operate on all such associated <a class="el" href="classArRangeDevice.html" title="The base class for all sensing devices which return range information from the device (mounted on a r...">ArRangeDevice</a> objects. This is a convenient (and thread-safe) way to access all range device data without depending on a specific set of individual range devices. For example, you can find the closest reading in a box or a polar section, no matter if that reading originated from the sonar, a laser, or other device. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="actionExample_8cpp-example.html#_a5">actionExample.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae5317e9755d5ef4ddda1acbfd5c79f2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArRangeDevice::ArRangeDevice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>currentBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cumulativeBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSecondsToKeepCurrent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSecondsToKeepCumulative</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistToKeepCumulative</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>locationDependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentBufferSize</td><td>number of readings to store in the current buffer</td></tr>
    <tr><td class="paramname">cumulativeBufferSize</td><td>number of readings to store in the cumulative buffer</td></tr>
    <tr><td class="paramname">name</td><td>the name of this device</td></tr>
    <tr><td class="paramname">maxRange</td><td>the maximum range of this device. If the device can't find a reading in a specified section, it returns this maxRange</td></tr>
    <tr><td class="paramname">maxSecondsToKeepCurrent</td><td>this is the number of seconds to keep current readings in the current buffer. If less than 0, then readings are not automatically removed based on time (but can be replaced or removed for other reasons). If 0, readings are removed immediately when a new set of readings is received and placed in the current buffer.</td></tr>
    <tr><td class="paramname">maxSecondsToKeepCumulative</td><td>this is the number of seconds to keep cumulative readings in the cumulative buffer. If less than 0 then readings are not automatically based on time (but can be replaced or removed for other reasons).</td></tr>
    <tr><td class="paramname">maxDistToKeepCumulative</td><td>if cumulative readings are further than this distance from the current robot pose, then they are removed. If this is less than 0 they are not removed because of this</td></tr>
    <tr><td class="paramname">locationDependent</td><td>if the data in this range device is dependent on the robot's location or not... For instance, a laser would not be dependent on location, because it'll be correct in a relative manner, whereas forbidden lines are dependent on location, because if the robot isn't where it thinks it is then the forbidden lines will be avoided in the wrong spots... this is mainly just a flag for other things to use when deciding what range devices to avoid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7774762a642a206a3b57bac9876ba5af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::adjustRawReadings </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interlaced</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This call should be called by the range device every robot cycle before the range device makes new readings (and even if it isn't adding any that cycle)... </p>
<p>it will adjust the raw readings by the robot odometry offset. The robot should be locked when this happens (which should be the case if you're doing it in the robot callback). The code currently assumes that all readings were taken at the same point, so if that isn't true with your device then you can't use this mechanism. </p>

</div>
</div>
<a class="anchor" id="ab7e29948ca6b640272faf43dfe5c4870"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::applyTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArTransform.html">ArTransform</a>&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doCumulative</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transform to the buffers. </p>
<p>Applies a coordinate transformation to some or all buffers.</p>
<p>This is mostly useful for translating to/from local/global coordinate systems, but may have other uses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trans</td><td>the transform to apply to the data </td></tr>
    <tr><td class="paramname">doCumulative</td><td>whether to transform the cumulative buffer or not </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classArLaser.html#a550a8f6002f7c6be0755d4ca5eb064a9">ArLaser</a>.</p>

</div>
</div>
<a class="anchor" id="adeab2edd7763ac30d2b33c1cf08bb915"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::cumulativeReadingBox </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArPose.html">ArPose</a> *&#160;</td>
          <td class="paramname"><em>pose</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the closest current reading from the given box region. </p>
<p>Get the closest reading in the cumulative buffer within a rectangular region around the range device, defined by two points (opposeite points of a rectangle).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>the x coordinate of one of the rectangle points </td></tr>
    <tr><td class="paramname">y1</td><td>the y coordinate of one of the rectangle points </td></tr>
    <tr><td class="paramname">x2</td><td>the x coordinate of the other rectangle point </td></tr>
    <tr><td class="paramname">y2</td><td>the y coordinate of the other rectangle point </td></tr>
    <tr><td class="paramname">pose</td><td>a pointer to an <a class="el" href="classArPose.html" title="Represents an x, y position with an orientation. ">ArPose</a> object in which to store the location of the closest position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The range to the reading from the device, or a value &gt;= maxRange if no reading was found in the box. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c898926eb1c04ed457c8e5c3e7566e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::cumulativeReadingPolar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>angle</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the closest cumulative reading in the given polar region. </p>
<p>The closest reading in this range device's cumulative buffer within a polar region or "slice" defined by the given angle range is returned.</p>
<p>Optionally return the specific angle of the found reading as well. The region searched is the region between a starting angle, sweeping counter-clockwise to the ending angle (0 is straight ahead of the device, -90 to the right, 90 to the left). Note that there is a difference between the region (0, 10) and (10, 0). (0, 10) is a 10-degree span near the front of the device, while (10, 0) is a 350 degree span covering the sides and rear. Similarly, (-60, -30) covers 30 degrees on the right hand side, while (-30, -60) covers 330 degrees. In other words, if you want the smallest section between the two angles, ensure than startAngle &lt; endAngle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startAngle</td><td>where to start the slice </td></tr>
    <tr><td class="paramname">endAngle</td><td>where to end the slice, going counterclockwise from startAngle </td></tr>
    <tr><td class="paramname">angle</td><td>if given, a pointer to a value in which to put the specific angle to the found reading </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range to the obstacle (a value &gt;= the maximum range indicates that no reading was detected in the specified region)</dd></dl>
<p><b>Python Wrapper Library:</b> <em>angle</em> is ignored</p>
<p>Example: </p><div class="image">
<img src="ArRangeDevice_currentReadingPolar.png" alt="ArRangeDevice_currentReadingPolar.png"/>
<div class="caption">
This figure illustrates an example range device and the meanings of arguments and return value.</div></div>
 
</div>
</div>
<a class="anchor" id="ac262870eb43b21b1be17ee8621eb3b91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::currentReadingBox </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArPose.html">ArPose</a> *&#160;</td>
          <td class="paramname"><em>pose</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the closest current reading from the given box region. </p>
<p>Get the closest reading in the current buffer within a rectangular region defined by two points (opposite corners of the rectangle).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>the x coordinate of one of the rectangle points </td></tr>
    <tr><td class="paramname">y1</td><td>the y coordinate of one of the rectangle points </td></tr>
    <tr><td class="paramname">x2</td><td>the x coordinate of the other rectangle point </td></tr>
    <tr><td class="paramname">y2</td><td>the y coordinate of the other rectangle point </td></tr>
    <tr><td class="paramname">pose</td><td>a pointer to an <a class="el" href="classArPose.html" title="Represents an x, y position with an orientation. ">ArPose</a> object in which to store the location of the closest position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The range to the reading from the device, or a value &gt;= maxRange if no reading was found in the box. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b080d64bdedd8f593ffcc6c373d609"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::currentReadingPolar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>angle</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the closest current reading in the given polar region. </p>
<p>The closest reading within a polar region (sector or slice) defined by the given angle range is returned.</p>
<p>Optionally, the specific angle of the found may be placed in <em>angle</em>, if not NULL. The region searched is the region between <em>startAngle</em>, sweeping counter-clockwise to <em>endAngle</em> (0 is straight ahead of the device, -90 to the right, 90 to the left). Note that therefore there is a difference between e.g. the regions (0, 10) and (10, 0). (0, 10) is a 10-degree span near the front of the device, while (10, 0) is a 350 degree span covering the sides and rear. Similarly, (-60, -30) covers 30 degrees on the right hand side, while (-30, -60) covers 330 degrees. (-90, 90) is 180 degrees in front. (-180, 180) covers all sides of the robot. In other words, if you want the smallest section between the two angles, ensure that <em>startAngle</em> &lt; <em>endAngle</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startAngle</td><td>where to start the slice </td></tr>
    <tr><td class="paramname">endAngle</td><td>where to end the slice, going counterclockwise from startAngle </td></tr>
    <tr><td class="paramname">angle</td><td>if given, a pointer to a value in which to put the specific angle to the found reading </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range to the obstacle (a value &gt;= the maximum range indicates that no reading was detected in the specified region)</dd></dl>
<p><b>Python Wrapper Library:</b> <em>angle</em> is ignored</p>
<p>Example: </p><div class="image">
<img src="ArRangeDevice_currentReadingPolar.png" alt="ArRangeDevice_currentReadingPolar.png"/>
<div class="caption">
This figure illustrates an example range device and the meanings of arguments and return value.</div></div>
 <dl><dt><b>Examples: </b></dt><dd><a class="el" href="laserConnect_8cpp-example.html#a23">laserConnect.cpp</a>, and <a class="el" href="lasers_8cpp-example.html#a29">lasers.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a08ad025cfa7204fb601f8b5de95bde9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::list&lt;<a class="el" href="classArSensorReading.html">ArSensorReading</a> *&gt;* ArRangeDevice::getAdjustedRawReadings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the raw unfiltered readings from the device (but pose takens are corrected) </p>
<p>The raw readings are the full set of unfiltered readings from the device. They are the latest readings. You should not manipulate the list you get from this function, the only manipulation of this list should be done by the range device itself. (Its only pointers for speed.)</p>
<p>This is like the raw readings but they were corrected for the robot odometry offset (just the pose taken, and encoder psoe taken).</p>
<dl class="section note"><dt>Note</dt><dd>Only lasers provides this data currently. Sonar, bumpers, etc. do not provide raw readings. </dd></dl>

</div>
</div>
<a class="anchor" id="ac41b98c9f5fdef7916a09433f871e940"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; * ArRangeDevice::getAdjustedRawReadingsAsVector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the raw adjusted readings from the device into a vector. </p>
<p>Copies the list into a vector.</p>
<p><b>Java and Python Wrappers:</b> The return type will be named ArSensorReadingVector instead of the std::vector template type. </p>

</div>
</div>
<a class="anchor" id="aad3ac9142453f941bc92ba241436453d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::list&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> *&gt;* ArRangeDevice::getCumulativeBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current buffer of readings. </p>
<p><b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#aaa8030e121b625a123286f98a328a5b2" title="Gets the cumulative buffer of readings as a vector. ">getCumulativeBufferAsVector()</a> </p>

</div>
</div>
<a class="anchor" id="aaa8030e121b625a123286f98a328a5b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a>&gt;* ArRangeDevice::getCumulativeBufferAsVector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cumulative buffer of readings as a vector. </p>
<p><b>Java and Python Wrappers:</b> The return type will be named ArPoseWithTimeVector instead of the std::vector template. </p>

</div>
</div>
<a class="anchor" id="aefc6078a128d80de304d5b978baaf31d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>* ArRangeDevice::getCumulativeRangeBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cumulative range buffer. </p>
<p><b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#aaa8030e121b625a123286f98a328a5b2" title="Gets the cumulative buffer of readings as a vector. ">getCumulativeBufferAsVector()</a> </p>

</div>
</div>
<a class="anchor" id="a072ac84980687ed353b3e5c2e36d6d68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::list&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> *&gt;* ArRangeDevice::getCurrentBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current buffer of readings. </p>
<p><b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#a91c1207063423f113406c9de528fc320" title="Gets the current buffer of readings as a vector. ">getCurrentBufferAsVector()</a> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="laserConnect_8cpp-example.html#a22">laserConnect.cpp</a>, and <a class="el" href="lasers_8cpp-example.html#a27">lasers.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a91c1207063423f113406c9de528fc320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a>&gt;* ArRangeDevice::getCurrentBufferAsVector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current buffer of readings as a vector. </p>
<p><b>Java and Python Wrappers:</b> The return type will be named ArPoseWithTimeVector instead of the std::vector template. </p>

</div>
</div>
<a class="anchor" id="ad5e497d7893beb13ef903861ba909087"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>* ArRangeDevice::getCurrentRangeBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current range buffer. </p>
<p><b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#a91c1207063423f113406c9de528fc320" title="Gets the current buffer of readings as a vector. ">getCurrentBufferAsVector()</a> </p>

</div>
</div>
<a class="anchor" id="aefc5cdd9adb55399d4e0725754c418ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::getMaxDistToKeepCumulative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the maximum distance cumulative readings can be from current pose </p>
<dl class="section return"><dt>Returns</dt><dd>if cumulative readings are further than this from where the current pose they are removed, if this is less than 0 they are not removed because of this </dd></dl>

</div>
</div>
<a class="anchor" id="a506d33c0b4e405476ce2b56097bcbce8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::getMaxInsertDistCumulative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum distance a cumulative reading can be from the robot and still be inserted. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum distance a cumulative reading can have from the robot's current position and still be inserted into the cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f9c853607709dd259d406c0356edc5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArRangeDevice::getMaxSecondsToKeepCumulative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets the maximum seconds to keep current readings around </p>
<dl class="section return"><dt>Returns</dt><dd>this is the number of seconds cumulative readings are kept around for, if less than 0 then they are not automatically removed because of this </dd></dl>

</div>
</div>
<a class="anchor" id="a51152724f047e69c2aec79bde36ece1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArRangeDevice::getMaxSecondsToKeepCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets the maximum seconds to keep current readings around </p>
<dl class="section return"><dt>Returns</dt><dd>this is the number of seconds current readings are kept around for, if less than 0 then they are not automatically removed because of this </dd></dl>

</div>
</div>
<a class="anchor" id="a900eac07d508c59f5026e423e7777864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::getMinDistBetweenCumulative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the minimum distance between cumulative readings. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum distance between cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>

</div>
</div>
<a class="anchor" id="aaafc983b6f747863b93c5258b18a4076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::getMinDistBetweenCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the minimum distance between current readings. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum distance between current readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3f1591ab4bcd08ffeab0254aaf7568b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::list&lt;<a class="el" href="classArSensorReading.html">ArSensorReading</a> *&gt;* ArRangeDevice::getRawReadings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the raw unfiltered readings from the device. </p>
<p>The raw readings are the full set of unfiltered readings from the device. They are the latest readings. You should not manipulate the list you get from this function, the only manipulation of this list should be done by the range device itself. (Its only pointers for speed.)</p>
<dl class="section note"><dt>Note</dt><dd>Only laser subclasses provide this data currently. Sonar, bumpers, etc. do not provide raw readings. This method was added to this base class for use by multiple laser or laser-like subclassses of <a class="el" href="classArRangeDevice.html" title="The base class for all sensing devices which return range information from the device (mounted on a r...">ArRangeDevice</a> and <a class="el" href="classArRangeDeviceThreaded.html" title="A range device which can run in its own thread. ">ArRangeDeviceThreaded</a> similar devices. Other kinds of range devices are sufficiently different from lasers that any "raw" information provided would usually require very different interpretation. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lasers_8cpp-example.html#a28">lasers.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a97fdf4c7e7c95ac8e5605df3c87ee1dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; * ArRangeDevice::getRawReadingsAsVector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the raw unfiltered readings from the device into a vector. </p>
<p>Copies the list into a vector.</p>
<p><b>Java and Python Wrappers:</b> The return type will be named ArSensorReadingVector instead of the std::vector template type. </p>

</div>
</div>
<a class="anchor" id="ad4f7fa1ed25b92afed4de0cb957c313c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setCumulativeBufferSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum size of the buffer for cumulative readings. </p>
<p>If the <em>size</em> is smaller than the cumulative buffer size, then the oldest readings are discarded, leaving only <em>size</em> newest readings.</p>
<p>If <em>size</em> is larger than the cumulative buffer size, then the buffer size will be allowed to grow to that size as new readings are added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of readings to set the buffer to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classArLaser.html#a5a7f8511f5798fe69367435254871d05">ArLaser</a>.</p>

</div>
</div>
<a class="anchor" id="a0e73bae003a4e3f89f8bddfc843db464"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setCurrentBufferSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum size of the buffer for current readings. </p>
<p>If the <em>size</em> is smaller than the current buffer size, then the oldest readings are discarded, leaving only <em>size</em> newest readings.</p>
<p>If <em>size</em> is larger than the current size, then the buffer size will be allowed to grow to that size as new readings are added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of readings to set the buffer's maximum size to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f1ec2efa5f2d6d34683586919847aa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMaxDistToKeepCumulative </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistToKeepCumulative</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the maximum distance cumulative readings can be from current pose </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDistToKeepCumulative</td><td>if cumulative readings are further than this from where the current pose they are removed, if this is less than 0 they are not removed because of this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65aaec7f213c343f6c096584928463cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMaxInsertDistCumulative </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxInsertDistCumulative</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum distance a cumulative reading can be from the robot and still be inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxInsertDistCumulative</td><td>The maximum distance a cumulative reading can have from the robot's current position and still be inserted into the cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d797854910a43b6650fb4cee3d8626f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMaxSecondsToKeepCumulative </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSecondsToKeepCumulative</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets the maximum seconds to keep cumulative readings around </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSecondsToKeepCumulative</td><td>this is the number of seconds to keep cumulative readings around, if less than 0 then they are not automatically removed because of this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab963e49e5a08704ac08ab7eab040fa8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMaxSecondsToKeepCurrent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSecondsToKeepCurrent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum seconds to keep current readings around. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSecondsToKeepCurrent</td><td>this is the number of seconds to keep current readings around, if less than 0 then they are not automatically removed because of this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd53bf7cfbba205118c79ab95c8c3f18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMinDistBetweenCumulative </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistBetweenCumulative</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the minimum distance between cumulative readings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minDistBetweenCumulative</td><td>The minimum distance between cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3b9e8840205f7d1b60a55f27490c1ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMinDistBetweenCurrent </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistBetweenCurrent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the minimum distance between current readings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minDistBetweenCurrent</td><td>The minimum distance between current readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ArRangeDevice.h</li>
<li>ArRangeDevice.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classArRangeDevice.html">ArRangeDevice</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
